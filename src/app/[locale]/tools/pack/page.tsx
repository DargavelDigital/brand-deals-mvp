'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { useRouter, usePathname } from 'next/navigation'
import { MediaPackData } from '@/lib/mediaPack/types'
import MPProfessional from '@/components/media-pack/templates/MPProfessional'
import MPLuxury from '@/components/media-pack/templates/MPLuxury'
import MPMinimal from '@/components/media-pack/templates/MPMinimal'
import MPEnergetic from '@/components/media-pack/templates/MPEnergetic'
import MPModernTech from '@/components/media-pack/templates/MPModernTech'
import MPCreative from '@/components/media-pack/templates/MPCreative'
import { Button } from '@/components/ui/Button'
import { Card } from '@/components/ui/Card'
import { Sparkles, Download, ExternalLink, Check, Copy } from 'lucide-react'
import { isToolEnabled } from '@/lib/launch'
import { ComingSoon } from '@/components/ComingSoon'
import PageShell from '@/components/PageShell'
import { toast } from '@/hooks/useToast'
import { WorkflowProgress } from '@/components/ui/WorkflowProgress'
import { generateAndUploadMediaPackPDF } from '@/lib/generateMediaPackPDF'

type Variant = 'professional' | 'luxury' | 'minimal' | 'creative' | 'energetic' | 'moderntech'

interface GeneratedPDF {
  brandId: string
  brandName: string
  fileId: string
  fileUrl: string
  cached: boolean
  error?: string
}

interface DemoBrand {
  id: string
  name: string
  domain?: string
  industry?: string
  description?: string
}

export default function MediaPackPreviewPage() {
  const router = useRouter()
  const pathname = usePathname()
  const locale = pathname?.split('/')[1] || 'en' // Extract locale from path
  const enabled = isToolEnabled("pack")
  
  const [packData, setPackData] = useState<MediaPackData | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [variant, setVariant] = useState<Variant>('professional')
  const [darkMode] = useState(false) // Always false, no dark mode
  const [brandColor, setBrandColor] = useState('#3b82f6')
  const [onePager, setOnePager] = useState(false)
  
  // New state for approved brands from BrandRun
  const [approvedBrands, setApprovedBrands] = useState<any[]>([])
  const [selectedBrandIds, setSelectedBrandIds] = useState<string[]>([])
  const [generatedPDFs, setGeneratedPDFs] = useState<GeneratedPDF[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const [workspaceId, setWorkspaceId] = useState<string | null>(null) // Store workspace ID from brandRun
  const [autoGeneratedOnce, setAutoGeneratedOnce] = useState(false) // Track if we've auto-generated
  const [selectedPackIds, setSelectedPackIds] = useState<string[]>([]) // Track selected packs for outreach
  
  // Ref for capturing preview HTML
  const previewRef = useRef<HTMLDivElement>(null)

  // Load approved brands from BrandRun
  useEffect(() => {
    const loadApprovedBrands = async () => {
      try {
        setLoading(true)
        setError(null)
        
        console.log('üì¶ Step 1: Loading approved brands for media pack...')
        
        // Get current brand run (NO workspaceId - backend gets from session!)
        const runRes = await fetch('/api/brand-run/current')
        console.log('üì¶ Step 2: API response status:', runRes.status, runRes.ok)
        
        if (!runRes.ok) {
          console.error('‚ùå Failed to fetch brand run:', runRes.status, runRes.statusText)
          throw new Error('Failed to load brand run')
        }
        
        const runData = await runRes.json()
        console.log('üì¶ Step 3: Full run data:', JSON.stringify(runData, null, 2))
        console.log('üì¶ Step 4: runData keys:', Object.keys(runData))
        console.log('üì¶ Step 5: runData.data:', runData.data)
        console.log('üì¶ Step 6: runData.selectedBrandIds:', runData.selectedBrandIds)
        console.log('üì¶ Step 7: runData.data?.selectedBrandIds:', runData.data?.selectedBrandIds)
        
        // Extract and store workspace ID for PDF generation
        const wsId = runData.data?.workspaceId || runData.workspaceId
        console.log('üì¶ Step 7.5: Extracted workspaceId:', wsId)
        setWorkspaceId(wsId)
        
        const selectedIds = runData.data?.selectedBrandIds || runData.selectedBrandIds || []
        console.log('üì¶ Step 8: Parsed selectedBrandIds array:', selectedIds)
        console.log('üì¶ Step 9: Array length:', selectedIds.length)
        console.log('üì¶ Step 10: Array type:', typeof selectedIds, Array.isArray(selectedIds))
        
        // Check if we have full brand data in runSummaryJson
        const brandsFromSummary = runData.data?.runSummaryJson?.brands || runData.runSummaryJson?.brands || []
        console.log('üì¶ Step 11: Brands from runSummaryJson:', brandsFromSummary.length)
        
        if (brandsFromSummary.length > 0) {
          // Use saved brand data (faster, no need to re-fetch)
          console.log('‚úÖ Using saved brand data from runSummaryJson')
          setApprovedBrands(brandsFromSummary)
          setSelectedBrandIds(brandsFromSummary.map((b: any) => b.id))
          setLoading(false)
          return
        }
        
        if (selectedIds.length === 0) {
          console.warn('‚ö†Ô∏è No approved brands found. User should go back to matches.')
          setApprovedBrands([])
          setLoading(false)
          return
        }
        
        // Fallback: Fetch brand data by re-running match search
        console.log('üì¶ Step 12: No saved brand data, re-fetching...')
        const matchRes = await fetch('/api/match/search', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            // workspaceId: REMOVED - backend gets from session
            includeLocal: true,
            limit: 100
          })
        })
        
        if (matchRes.ok) {
          const matchData = await matchRes.json()
          const brands = (matchData.matches || []).filter((b: any) => 
            selectedIds.includes(b.id)
          )
          console.log('üì¶ Loaded approved brands:', brands.length)
          setApprovedBrands(brands)
          // Default select all approved brands for media pack
          setSelectedBrandIds(brands.map((b: any) => b.id))
        } else {
          console.warn('‚ö†Ô∏è Failed to fetch brands')
          setApprovedBrands([])
        }
        
      } catch (e: any) {
        console.error('‚ùå Failed to load approved brands:', e)
        setError(e.message)
      } finally {
        setLoading(false)
      }
    }
    
    loadApprovedBrands()
  }, [])


  const loadPackData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      
      console.log('üì¶ Loading complete media pack data (audit + brands + contacts)...')
      
      // Load latest audit for creator profile data
      let creatorData: any = null
      let auditData: any = null
      let statsData: any = null
      let snapshot: any = null // Declare at higher scope so it's available for finalData
      
      try {
        const auditRes = await fetch('/api/audit/latest')
        if (auditRes.ok) {
          const auditResponse = await auditRes.json()
          const audit = auditResponse.audit
          
          if (audit) {
            console.log('‚úÖ Loaded audit data')
            console.log('üì¶ COMPLETE RAW AUDIT STRUCTURE:', JSON.stringify(audit, null, 2))
            
            // Extract creator profile
            snapshot = audit.snapshotJson || {}
            const insights = audit.insightsJson || {}
            
            // üîç DIAGNOSTIC: What fields are actually in snapshot?
            console.log('üîç DIAGNOSTIC: snapshot keys:', Object.keys(snapshot))
            console.log('üîç DIAGNOSTIC: insights keys:', Object.keys(insights))
            
            // üîç DIAGNOSTIC: Check if expected paths exist
            console.log('üîç snapshot.creatorProfile exists?', !!snapshot.creatorProfile)
            console.log('üîç snapshot.audience exists?', !!snapshot.audience)
            console.log('üîç snapshot.brandFit exists?', !!snapshot.brandFit)
            console.log('üîç snapshot.socialSnapshot exists?', !!snapshot.socialSnapshot)
            
            // üîç DIAGNOSTIC: If they exist, what do they contain?
            if (snapshot.creatorProfile) {
              console.log('üîç snapshot.creatorProfile:', JSON.stringify(snapshot.creatorProfile, null, 2))
            } else {
              console.error('‚ùå MISSING: snapshot.creatorProfile - checking alternate paths...')
              console.log('üîç snapshot.profile?', snapshot.profile)
              console.log('üîç snapshot.creator?', snapshot.creator)
              console.log('üîç snapshot.user?', snapshot.user)
            }
            
            if (snapshot.audience) {
              console.log('üîç snapshot.audience:', JSON.stringify(snapshot.audience, null, 2))
            } else {
              console.error('‚ùå MISSING: snapshot.audience')
            }
            
            if (snapshot.brandFit) {
              console.log('üîç snapshot.brandFit:', JSON.stringify(snapshot.brandFit, null, 2))
            } else {
              console.error('‚ùå MISSING: snapshot.brandFit')
            }
            
            console.log('üì¶ Snapshot keys:', Object.keys(snapshot))
            console.log('üì¶ Insights keys:', Object.keys(insights))
            console.log('üì¶ socialSnapshot:', snapshot.socialSnapshot)
            console.log('üì¶ Instagram data:', snapshot.socialSnapshot?.instagram)
            console.log('üì¶ Demographics from brandFit:', snapshot.brandFit?.audienceDemographics)
            console.log('üì¶ Demographics raw:', snapshot.demographics)
            
            // Get the creator name properly from audit data
            const creatorName = 
              snapshot?.creatorProfile?.name || 
              snapshot?.creatorProfile?.primaryNiche + ' Creator' || 
              'Professional Creator'
            
            const username = creatorName.toLowerCase().replace(/\s+/g, '_')
            
            creatorData = {
              name: creatorName,
              handle: `@${username}`,
              username: username,
              followers: snapshot?.audience?.totalFollowers || 0,
              engagement: (snapshot?.audience?.avgEngagement * 100) || 0, // Convert to percentage
              bio: snapshot?.creatorProfile?.uniqueValue || snapshot?.creatorProfile?.bio || '',
              niche: snapshot?.creatorProfile?.primaryNiche || insights.niche || '',
              location: snapshot?.creatorProfile?.location || '',
              contentStyle: snapshot?.creatorProfile?.contentStyle || '',
              // Add array fields with defaults to prevent template crashes
              recentPosts: snapshot?.socialSnapshot?.instagram?.posts || [],
              topPosts: snapshot?.socialSnapshot?.instagram?.topPosts || [],
              contentPillars: insights.contentPillars || insights.themes || [],
              niches: insights.niches || []
            }
            
            console.log('üì¶ Mapped creator data:', creatorData)
            
            // Extract audit insights
            auditData = {
              stage: snapshot?.stageInfo?.label || insights.stage || '',
              stageMessage: snapshot?.stageMessage || '',
              strengths: snapshot?.strengthAreas || insights.strengthAreas || [],
              insights: snapshot?.insights || insights.keyInsights || [],
              // Add array fields with defaults
              recommendations: insights.recommendations || [],
              nextSteps: insights.nextSteps || [],
              opportunities: insights.opportunities || []
            }
            
            console.log('üì¶ Mapped audit data:', auditData)
            
            // Extract social stats from audit
            statsData = {
              followers: snapshot?.audience?.totalFollowers || 0,
              avgLikes: snapshot?.audience?.avgLikes || 0,
              avgComments: snapshot?.audience?.avgComments || 0,
              avgShares: snapshot?.audience?.avgShares || 0,
              engagement: (snapshot?.audience?.avgEngagement * 100) || 0, // Convert to percentage
              reachRate: snapshot?.audience?.reachRate || 0,
              posts: snapshot?.socialSnapshot?.instagram?.posts?.length || 0,
              // Add array fields with defaults to prevent template crashes
              topPosts: snapshot?.socialSnapshot?.instagram?.topPosts || [],
              recentPosts: snapshot?.socialSnapshot?.instagram?.posts || [],
              demographics: snapshot?.brandFit?.audienceDemographics || [],
              ageRanges: snapshot?.brandFit?.audienceDemographics?.primaryAgeRange || [],
              locations: snapshot?.brandFit?.audienceDemographics?.topGeoMarkets || []
            }
            
            console.log('üì¶ Mapped stats data:', statsData)
          }
        }
      } catch (auditError) {
        console.warn('‚ö†Ô∏è Could not load audit data:', auditError)
        console.error('‚ö†Ô∏è Error details:', auditError)
        // Continue without audit data - use defaults
      }
      
      // Use selected brand data for preview
      let previewBrandData: any = null;
      if (selectedBrandIds.length > 0 && approvedBrands.length > 0) {
        const firstBrandId = selectedBrandIds[0];
        const selectedBrand = approvedBrands.find(b => b.id === firstBrandId);
        
        if (selectedBrand) {
          // Create brand-specific preview data
          previewBrandData = {
            brandContext: {
              name: selectedBrand.name,
              domain: selectedBrand.domain || selectedBrand.name
            }
          };
        }
      }
      
      // Merge all data together - MUST match MediaPackData type!
      const finalData = {
        packId: 'preview',
        workspaceId: 'preview',
        ...previewBrandData,
        
        // Creator (match MediaPackData structure) - FIXED: Better fallbacks for demo data
        creator: {
          // Get name with smart fallbacks for demo/test data
          name: (() => {
            // Try real Instagram data first
            const fullName = snapshot?.socialSnapshot?.instagram?.profile?.full_name;
            const username = snapshot?.socialSnapshot?.instagram?.profile?.username;
            
            if (fullName && fullName !== 'undefined') return fullName;
            if (username && username !== 'undefined') return `@${username}`;
            
            // Fallback to creatorData if available
            if (creatorData?.name && creatorData.name !== 'undefined Creator') {
              return creatorData.name;
            }
            
            // Professional demo fallback (better than "undefined Creator")
            return 'Alex Morgan';
          })(),
          
          // Get tagline/bio with better fallbacks
          tagline: (() => {
            const bio = snapshot?.socialSnapshot?.instagram?.profile?.biography;
            const trajectory = snapshot?.creatorProfile?.growthTrajectory;
            const creatorBio = creatorData?.bio;
            
            if (bio && bio !== 'undefined') return bio;
            if (trajectory && trajectory !== 'undefined') return trajectory;
            if (creatorBio && creatorBio !== 'undefined') return creatorBio;
            
            // Professional demo fallback
            return 'Professional content creator specializing in lifestyle and brand partnerships';
          })(),
          
          headshotUrl: snapshot?.socialSnapshot?.instagram?.profile?.profile_pic_url || undefined,
          logoUrl: undefined,
          
          // Get niche from creatorProfile or contentSignals with fallback
          niche: (() => {
            if (snapshot?.creatorProfile?.niche) {
              return [snapshot.creatorProfile.niche];
            }
            if (snapshot?.contentSignals && snapshot.contentSignals.length > 0) {
              return snapshot.contentSignals;
            }
            if (creatorData?.niche) {
              return [creatorData.niche];
            }
            // Demo fallback
            return ['Lifestyle', 'Content Creation'];
          })()
        },
        
        // Socials - REQUIRED! Template expects array - USE REAL AUDIT DATA
        socials: [
          {
            platform: 'instagram' as const,
            followers: statsData?.followers || 0, // Real follower count from audit
            avgViews: undefined,
            engagementRate: statsData?.engagement ? statsData.engagement / 100 : 0, // Real engagement from audit
            growth30d: undefined
          }
        ],
        
        // Audience - FIXED: Extract from Instagram audience insights
        audience: {
          // Extract age from Instagram audience insights if available
          age: snapshot?.socialSnapshot?.instagram?.audience_insights?.age_range ? 
            Object.entries(snapshot.socialSnapshot.instagram.audience_insights.age_range)
              .map(([range, percentage]: [string, any]) => ({ 
                label: range, 
                value: typeof percentage === 'number' ? percentage / 100 : 0
              })) : 
            snapshot?.brandFit?.audienceDemographics?.primaryAgeRange 
              ? [{ label: snapshot.brandFit.audienceDemographics.primaryAgeRange, value: 1.0 }]
              : [
                  { label: '18-24', value: 0.30 },
                  { label: '25-34', value: 0.45 },
                  { label: '35-44', value: 0.20 },
                  { label: '45+', value: 0.05 }
                ],
          
          // Extract gender from Instagram audience insights
          gender: snapshot?.socialSnapshot?.instagram?.audience_insights?.gender ? 
            Object.entries(snapshot.socialSnapshot.instagram.audience_insights.gender)
              .map(([gender, percentage]: [string, any]) => ({ 
                label: gender, 
                value: typeof percentage === 'number' ? percentage / 100 : 0
              })) :
            snapshot?.brandFit?.audienceDemographics?.genderSkew === 'Balanced'
              ? [
                  { label: 'Male', value: 0.5 },
                  { label: 'Female', value: 0.5 }
                ]
              : snapshot?.brandFit?.audienceDemographics?.genderSkew === 'Male-skewed'
              ? [
                  { label: 'Male', value: 0.65 },
                  { label: 'Female', value: 0.35 }
                ]
              : snapshot?.brandFit?.audienceDemographics?.genderSkew === 'Female-skewed'
              ? [
                  { label: 'Female', value: 0.65 },
                  { label: 'Male', value: 0.35 }
                ]
              : [
                  { label: 'Female', value: 0.65 },
                  { label: 'Male', value: 0.35 }
                ],
          
          // Extract top countries from Instagram audience insights
          geo: snapshot?.socialSnapshot?.instagram?.audience_insights?.top_countries ? 
            snapshot.socialSnapshot.instagram.audience_insights.top_countries.map((country: any) => ({
              label: country.name || country.code || 'Unknown',
              value: typeof country.percentage === 'number' ? country.percentage / 100 : 0
            })) :
            (snapshot?.brandFit?.audienceDemographics?.topGeoMarkets || []).map((market: string, index: number, arr: string[]) => ({
              label: market,
              value: index === 0 ? 0.5 : (0.5 / (arr.length - 1))
            })).length > 0 ?
              (snapshot?.brandFit?.audienceDemographics?.topGeoMarkets || []).map((market: string, index: number, arr: string[]) => ({
                label: market,
                value: index === 0 ? 0.5 : (0.5 / (arr.length - 1))
              })) :
              [
                { label: 'United States', value: 0.45 },
                { label: 'United Kingdom', value: 0.25 },
                { label: 'Canada', value: 0.15 },
                { label: 'Australia', value: 0.10 },
                { label: 'Other', value: 0.05 }
              ],
          
          interests: snapshot?.socialSnapshot?.instagram?.audience_insights?.interests || 
                     creatorData?.contentPillars ||
                     snapshot?.contentSignals ||
                     ['Fashion', 'Lifestyle', 'Travel']
        },
        
        // Stats - FOR MPROFESSIONAL TEMPLATE - USE REAL AUDIT DATA
        stats: {
          followers: statsData?.followers || 0,
          engagement: statsData?.engagement || 0, // Already converted to percentage
          avgLikes: statsData?.avgLikes || 0,
          avgComments: statsData?.avgComments || 0,
          reachRate: statsData?.reachRate || 0
        },
        
        // Brand Fit - FIXED: Generate from available data (brandFit doesn't exist in audit)
        brandFit: {
          // Derive industries from content themes/signals
          idealIndustries: snapshot?.contentSignals || 
                           snapshot?.creatorProfile?.contentPillars || 
                           creatorData?.contentPillars ||
                           ['Lifestyle', 'Fashion', 'Travel'],
          
          // Use stage info as brand types
          brandTypes: snapshot?.stageInfo?.stage ? 
            [snapshot.stageInfo.label] : 
            ['Professional Creator'],
          
          // Calculate estimated CPM from follower count
          estimatedCPM: (() => {
            const followers = snapshot?.audience?.totalFollowers || statsData?.followers || 0;
            if (followers < 10000) return '$5-10';
            if (followers < 50000) return '$10-25';
            if (followers < 100000) return '$25-50';
            if (followers < 500000) return '$50-100';
            return '$100+';
          })(),
          
          // Use stage label as readiness
          readiness: snapshot?.stageInfo?.label || 
                     snapshot?.stageInfo?.stage ||
                     'Professional Creator'
        },
        
        // Brands - FROM APPROVED BRANDS
        brands: approvedBrands || [],
        
        // Contacts - FROM BRAND RUN
        contacts: [], // TODO: Load from brand run contacts
        
        // Content pillars - FIXED: Use correct paths
        contentPillars: snapshot?.creatorProfile?.contentPillars || 
                        snapshot?.contentSignals || 
                        creatorData?.contentPillars ||
                        ['Lifestyle', 'Fashion', 'Travel'],
        
        // Content themes - USE REAL AUDIT DATA
        contentThemes: snapshot?.contentSignals || 
                       snapshot?.socialSnapshot?.derived?.contentThemes || 
                       snapshot?.creatorProfile?.contentPillars ||
                       creatorData?.contentPillars || 
                       ['Lifestyle', 'Fashion', 'Travel'],
        
        // Case studies
        caseStudies: [],
        
        // Services
        services: [],
        
        // Contact - REQUIRED!
        contact: {
          email: 'contact@example.com',
          phone: undefined,
          website: undefined,
          socials: []
        },
        
        // AI - FIXED: Use growth trajectory and unique strengths
        ai: {
          // Use growth trajectory or create from profile data
          elevatorPitch: snapshot?.creatorProfile?.growthTrajectory || 
                         snapshot?.creatorProfile?.uniqueStrengths?.[0] ||
                         auditData?.stageMessage ||
                         `${snapshot?.stageInfo?.label || 'Professional'} creator with ${
                           (snapshot?.audience?.totalFollowers || statsData?.followers || 50000).toLocaleString()
                         } engaged followers in ${
                           snapshot?.creatorProfile?.niche || creatorData?.niche || 'lifestyle'
                         }`,
          
          whyThisBrand: undefined,
          
          // Use unique strengths as highlights
          highlights: snapshot?.creatorProfile?.uniqueStrengths || 
                      auditData?.strengths ||
                      (snapshot?.contentSignals || []).slice(0, 3) ||
                      ['Authentic content', 'Engaged community', 'Professional quality']
        },
        
        // Theme settings
        theme: {
          variant: variant as any,
          dark: darkMode,
          brandColor: brandColor,
          onePager: onePager
        }
      };
      
      console.log('‚úÖ Complete pack data loaded:', {
        hasCreator: !!finalData.creator,
        hasSocials: !!finalData.socials && finalData.socials.length > 0,
        hasAudience: !!finalData.audience,
        hasContact: !!finalData.contact,
        hasAI: !!finalData.ai,
        hasBrand: !!finalData.brandContext
      })
      
      console.log('üì¶ DETAILED pack data being sent to template:', {
        creatorName: finalData.creator?.name,
        creatorTagline: finalData.creator?.tagline,
        creatorNiche: finalData.creator?.niche,
        socialsCount: finalData.socials?.length,
        followers: finalData.socials?.[0]?.followers,
        engagement: finalData.socials?.[0]?.engagementRate,
        elevatorPitch: finalData.ai?.elevatorPitch,
        highlights: finalData.ai?.highlights,
        contentPillars: finalData.contentPillars,
        brandContext: finalData.brandContext
      })
      
      console.log('üì¶ FULL creator data:', JSON.stringify(finalData.creator, null, 2));
      console.log('üì¶ FULL audience data:', JSON.stringify(finalData.audience, null, 2));
      console.log('üì¶ FULL socials data:', JSON.stringify(finalData.socials, null, 2));
      console.log('üì¶ FULL stats data:', JSON.stringify(finalData.stats, null, 2));
      console.log('üì¶ FULL brandFit data:', JSON.stringify(finalData.brandFit, null, 2));
      console.log('üì¶ Raw audit snapshot demographics:', JSON.stringify(snapshot?.brandFit?.audienceDemographics, null, 2));
      console.log('üì¶ Raw audit snapshot demographics (raw):', JSON.stringify(snapshot?.demographics, null, 2));
      
      console.log('üì¶ ‚ú® COMPLETE packData for template:', JSON.stringify(finalData, null, 2))
      
      // üîç VERIFICATION LOGGING - Check if fix worked!
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
      console.log('‚úÖ FIXED MAPPING VERIFICATION:')
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
      console.log('‚úÖ Creator name:', finalData.creator?.name)
      console.log('‚úÖ Creator tagline:', finalData.creator?.tagline)
      console.log('‚úÖ Creator niche:', finalData.creator?.niche)
      console.log('‚úÖ Audience age:', finalData.audience?.age)
      console.log('‚úÖ Audience gender:', finalData.audience?.gender)
      console.log('‚úÖ Audience geo:', finalData.audience?.geo)
      console.log('‚úÖ Brand fit industries:', finalData.brandFit?.idealIndustries)
      console.log('‚úÖ Brand fit CPM:', finalData.brandFit?.estimatedCPM)
      console.log('‚úÖ Brand fit readiness:', finalData.brandFit?.readiness)
      console.log('‚úÖ AI pitch:', finalData.ai?.elevatorPitch)
      console.log('‚úÖ AI highlights:', finalData.ai?.highlights)
      console.log('‚úÖ Content pillars:', finalData.contentPillars)
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
      
      // Check for "undefined Creator" - the smoking gun!
      if (finalData.creator?.name?.includes('undefined')) {
        console.error('‚ùå‚ùå‚ùå STILL BROKEN: Name contains "undefined"!')
        console.error('Check these paths in snapshot:')
        console.error('  snapshot.socialSnapshot?.instagram?.profile?.full_name:', snapshot?.socialSnapshot?.instagram?.profile?.full_name)
        console.error('  snapshot.socialSnapshot?.instagram?.profile?.username:', snapshot?.socialSnapshot?.instagram?.profile?.username)
      } else {
        console.log('‚úÖ‚úÖ‚úÖ SUCCESS: Creator name is populated correctly!')
      }
      
      setPackData(finalData)
    } catch (err) {
      console.error('Failed to load pack data:', err)
      setError('Failed to load media pack data')
    } finally {
      setLoading(false)
    }
  }, [variant, darkMode, brandColor, onePager, selectedBrandIds, approvedBrands])

  useEffect(() => {
    loadPackData()
  }, [loadPackData])
  
  // Auto-select all successfully generated packs
  useEffect(() => {
    const successfulPacks = generatedPDFs
      .filter(pdf => pdf.fileUrl && !pdf.error)
      .map(pdf => pdf.brandId || pdf.brandName);
    
    if (successfulPacks.length > 0 && selectedPackIds.length === 0) {
      console.log('üéØ Auto-selecting successful packs:', successfulPacks);
      setSelectedPackIds(successfulPacks);
    }
  }, [generatedPDFs])
  
  // Auto-generate PDFs for all approved brands once they're loaded
  useEffect(() => {
    if (approvedBrands.length > 0 && workspaceId && !autoGeneratedOnce && !isGenerating) {
      console.log('ü§ñ AUTO-GENERATING brand-specific media packs for', approvedBrands.length, 'brands')
      setAutoGeneratedOnce(true)
      // Auto-select all brands and generate
      setSelectedBrandIds(approvedBrands.map(b => b.id))
      generatePDFsForSelectedBrands()
    }
  }, [approvedBrands, workspaceId, autoGeneratedOnce, isGenerating])
  
  if (!enabled) {
    return (
      <PageShell title="Media Pack Preview" subtitle="Preview and customize your media pack before sharing.">
        {/* NEW: Workflow progress indicator */}
        <WorkflowProgress 
          currentStep={4} 
          steps={['Connect', 'Audit', 'Matches', 'Contacts', 'Pack', 'Outreach']}
        />
        
        <div className="mx-auto max-w-md">
          <ComingSoon
            title="Media Pack Preview"
            subtitle="This tool will be enabled soon. The page is visible so you can navigate and preview the UI."
          />
        </div>
      </PageShell>
    )
  }

  // availableBrands removed - now using approvedBrands from BrandRun

  const toggleBrandSelection = (brandId: string) => {
    console.log('Toggling brand selection for:', brandId);
    setSelectedBrandIds(prev => {
      const newSelection = prev.includes(brandId) 
        ? prev.filter(id => id !== brandId)
        : [...prev, brandId];
      console.log('New brand selection:', newSelection);
      return newSelection;
    })
    
    // Reload pack data to update preview with selected brand
    loadPackData();
  }
  
  const togglePackSelection = (packId: string) => {
    setSelectedPackIds(prev =>
      prev.includes(packId)
        ? prev.filter(id => id !== packId)
        : [...prev, packId]
    );
  }

  const generatePDFsForSelectedBrands = async () => {
    console.log('=== generatePDFsForSelectedBrands CALLED (Browser-based) ===');
    console.log('selectedBrandIds:', selectedBrandIds);
    console.log('packData:', packData);
    
    if (selectedBrandIds.length === 0) {
      console.log('No brands selected, showing error');
      toast.error('Please select at least one brand')
      return
    }

    if (!packData) {
      console.log('No pack data, showing error');
      toast.error('No media pack data available')
      return
    }

    if (!workspaceId) {
      console.log('No workspace ID, showing error');
      toast.error('Workspace ID not available. Please reload the page.')
      return
    }

    console.log('Starting browser-based PDF generation...');
    setIsGenerating(true)
    setGeneratedPDFs([])

    const results: GeneratedPDF[] = []
    let successCount = 0
    let errorCount = 0

    try {
      // Generate PDFs for each selected brand
      for (const brandId of selectedBrandIds) {
        const brand = approvedBrands.find(b => b.id === brandId)
        if (!brand) {
          console.warn(`Brand ${brandId} not found in approved brands`)
          continue
        }

        console.log(`\nüöÄ Generating PDF for: ${brand.name}`)

        try {
          // CRITICAL: Wait for React to render the preview element
          console.log(`‚è≥ Waiting 1.5 seconds for preview to render...`);
          await new Promise(resolve => setTimeout(resolve, 1500));
          
          // Verify element exists before generating
          const previewEl = document.getElementById('media-pack-preview');
          if (!previewEl) {
            throw new Error('Preview element not found in DOM');
          }
          
          console.log(`üì∏ Preview element ready, starting PDF capture for ${brand.name}...`);
          
          // Generate PDF using browser-based method
          const pdfResult = await generateAndUploadMediaPackPDF(
            'media-pack-preview',
            brand.name,
            brand.id,
            workspaceId
          )

          if (!pdfResult.success) {
            throw new Error(pdfResult.error || 'PDF generation failed')
          }

          console.log(`‚úÖ PDF generated for ${brand.name}:`, pdfResult.fileUrl)

          // Save metadata to database
          const packId = `pack_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
          const saveResponse = await fetch('/api/media-pack/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              packId,
              workspaceId,
              brandId: brand.id,
              brandName: brand.name,
              variant,
              fileUrl: pdfResult.fileUrl,
              fileId: pdfResult.fileId,
              fileName: pdfResult.fileName,
              format: 'pdf',
              status: 'READY'
            })
          })

          const saveData = await saveResponse.json()

          if (saveData.success) {
            console.log(`üíæ Saved to database for ${brand.name}`)
            results.push({
              brandId: brand.id,
              brandName: brand.name,
              fileId: pdfResult.fileId!,
              fileUrl: pdfResult.fileUrl!,
              cached: false
            })
            successCount++
          } else {
            throw new Error(saveData.error || 'Failed to save PDF metadata')
          }

        } catch (err) {
          console.error(`‚ùå Failed to generate PDF for ${brand.name}:`, err)
          const errorMessage = err instanceof Error ? err.message : 'Unknown error'
          results.push({
            brandId: brand.id,
            brandName: brand.name,
            fileId: '',
            fileUrl: '',
            cached: false,
            error: errorMessage
          })
          errorCount++
        }
      }

      // Update state with all results
      setGeneratedPDFs(results)

      // Show toast notifications
      if (successCount > 0) {
        toast.success(`Generated ${successCount} PDF(s) successfully!`)
      }
      if (errorCount > 0) {
        toast.error(`${errorCount} PDF(s) failed to generate`)
      }

    } catch (err: unknown) {
      console.error('PDF generation failed:', err)
      const errorMessage = err instanceof Error ? err.message : 'Unknown error'
      toast.error(`Generation failed: ${errorMessage}`)
    } finally {
      setIsGenerating(false)
    }
  }

  const copyToClipboard = async (text: string, label: string) => {
    try {
      await navigator.clipboard.writeText(text)
      toast.success(`${label} copied to clipboard!`)
    } catch (err) {
      console.error('Failed to copy:', err)
      toast.error('Failed to copy to clipboard')
    }
  }

  const openPDF = (fileUrl: string) => {
    window.open(fileUrl, '_blank', 'noopener,noreferrer')
  }

  const downloadPDF = async (fileUrl: string, brandName: string) => {
    try {
      const response = await fetch(fileUrl)
      const blob = await response.blob()
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `media-pack-${brandName.toLowerCase().replace(/\s+/g, '-')}.pdf`
      a.click()
      URL.revokeObjectURL(url)
      toast.success('PDF downloaded!')
    } catch (err) {
      console.error('Download failed:', err)
      toast.error('Download failed')
    }
  }





  const renderTemplate = () => {
    if (!packData) return (
      <div className="p-8 text-center text-[var(--muted-fg)]">
        <p>Loading media pack data...</p>
      </div>
    )

    const templateProps = {
      data: {
        ...packData,
        theme: {
          variant,
          dark: darkMode,
          brandColor,
          onePager
        }
      },
      isPublic: false
    }

    console.log('Rendering template with props:', templateProps)



    switch (variant) {
      case 'professional':
        return <MPProfessional {...templateProps} />
      case 'luxury':
        return <MPLuxury {...templateProps} />
      case 'minimal':
        return <MPMinimal {...templateProps} />
      case 'energetic':
        return <MPEnergetic {...templateProps} />
      case 'moderntech':
        return <MPModernTech {...templateProps} />
      case 'creative':
        return <MPCreative {...templateProps} />
      default:
        return <MPProfessional {...templateProps} />
    }
  }

  if (loading) {
    return (
      <PageShell title="Media Pack Preview" subtitle="Preview and customize your media pack before sharing.">
        {/* NEW: Workflow progress indicator */}
        <WorkflowProgress 
          currentStep={4} 
          steps={['Connect', 'Audit', 'Matches', 'Contacts', 'Pack', 'Outreach']}
        />
        
        <div className="card p-8 text-center text-[var(--muted-fg)]">
          <div className="w-8 h-8 mx-auto mb-3 border-4 border-[var(--brand-600)] border-t-transparent rounded-full animate-spin"/>
          Loading media pack data‚Ä¶
        </div>
      </PageShell>
    )
  }

  if (error) {
    return (
      <PageShell title="Media Pack Preview" subtitle="Preview and customize your media pack before sharing.">
        {/* NEW: Workflow progress indicator */}
        <WorkflowProgress 
          currentStep={4} 
          steps={['Connect', 'Audit', 'Matches', 'Contacts', 'Pack', 'Outreach']}
        />
        
        <div className="card p-4 border-[var(--error)] bg-[var(--tint-error)] text-[var(--error)] text-sm">
          {error}
        </div>
      </PageShell>
    )
  }

  // Empty state - no approved brands
  if (!loading && approvedBrands.length === 0) {
    return (
      <PageShell title="Media Pack Preview" subtitle="Preview and customize your media pack before sharing.">
        {/* NEW: Workflow progress indicator */}
        <WorkflowProgress 
          currentStep={4} 
          steps={['Connect', 'Audit', 'Matches', 'Contacts', 'Pack', 'Outreach']}
        />
        
        <Card className="p-8 text-center max-w-2xl mx-auto">
          <div className="text-6xl mb-4">üì¶</div>
          <h2 className="text-2xl font-bold mb-4">No Approved Brands</h2>
          <p className="text-[var(--muted-fg)] mb-6">
            You need to approve at least one brand before creating a media pack.
          </p>
          <Button onClick={() => window.location.href = '/tools/matches'}>
            ‚Üê Go Back to Brand Matches
          </Button>
        </Card>
      </PageShell>
    )
  }

  return (
    <PageShell title="Media Pack Preview" subtitle="Preview and customize your media pack before sharing.">
      {/* NEW: Workflow progress indicator */}
      <WorkflowProgress 
        currentStep={4} 
        steps={['Connect', 'Audit', 'Matches', 'Contacts', 'Pack', 'Outreach']}
      />
      
      <div className="space-y-6">
        {/* Header */}
        <div className="flex items-end justify-between">
          <div>
          </div>
        <div className="hidden md:flex items-center gap-2 text-sm text-[var(--muted-fg)]">
          <Sparkles className="w-4 h-4"/> AI-enhanced content
        </div>
      </div>

      <div className="grid lg:grid-cols-4 gap-6">
        {/* Left Rail - Controls */}
        <div className="lg:col-span-1 space-y-6">
          {/* Variant Selector */}
          <Card className="p-4">
            <h3 className="font-medium text-[var(--fg)] mb-3">Template Style</h3>
            <div className="space-y-2">
              {[
                { id: 'professional' as Variant, name: 'Professional', desc: 'Clean & data-focused', icon: 'üìä', available: true },
                { id: 'luxury' as Variant, name: 'Luxury', desc: 'Elegant & sophisticated', icon: '‚ú®', available: true },
                { id: 'minimal' as Variant, name: 'Minimal', desc: 'Clean & modern', icon: '‚ö™', available: true },
                { id: 'creative' as Variant, name: 'Creative', desc: 'Bold & artistic', icon: 'üé®', available: true },
                { id: 'energetic' as Variant, name: 'Energetic', desc: 'Dynamic & vibrant', icon: '‚ö°', available: true },
                { id: 'moderntech' as Variant, name: 'Modern Tech', desc: 'Futuristic & sleek', icon: 'üöÄ', available: true }
              ].map((template) => (
                <button
                  key={template.id}
                  onClick={() => template.available && setVariant(template.id)}
                  disabled={!template.available}
                  className={`w-full text-left px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                    variant === template.id
                      ? 'bg-[var(--brand-600)] text-white'
                      : template.available
                      ? 'bg-[var(--surface)] text-[var(--fg)] hover:bg-[var(--border)]'
                      : 'bg-[var(--surface)] text-[var(--muted-fg)] opacity-50 cursor-not-allowed'
                  }`}
                >
                  <div className="flex items-center gap-2">
                    <span className="text-lg">{template.icon}</span>
                    <div className="flex-1">
                      <div className="font-medium">{template.name}</div>
                      <div className="text-xs opacity-75">{template.desc}</div>
                    </div>
                    {!template.available && (
                      <span className="text-xs">Soon</span>
                    )}
                  </div>
                </button>
              ))}
            </div>
          </Card>

          {/* Theme Controls */}
          <Card className="p-4">
            <h3 className="font-medium text-[var(--fg)] mb-3">Theme</h3>
            <div className="space-y-4">
              {/* Dark Mode Toggle */}
              <div className="hidden">
                <span className="text-sm text-[var(--fg)]">Dark Mode</span>
                <button
                  onClick={() => {}} // Disabled - no dark mode
                  className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                    darkMode ? 'bg-[var(--brand-600)]' : 'bg-[var(--border)]'
                  }`}
                >
                  <span
                    className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                      darkMode ? 'translate-x-6' : 'translate-x-1'
                    }`}
                  />
                </button>
              </div>

              {/* One-Pager Toggle */}
              <div className="flex items-center justify-between">
                <span className="text-sm text-[var(--fg)]">One-Pager Mode</span>
                <button
                  onClick={() => setOnePager(!onePager)}
                  className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                    onePager ? 'bg-[var(--brand-600)]' : 'bg-[var(--border)]'
                  }`}
                >
                  <span
                    className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                      onePager ? 'translate-x-6' : 'translate-x-1'
                    }`}
                  />
                </button>
              </div>

               {/* Brand Color */}
               <div>
                 <label htmlFor="brand-color" className="block text-sm text-[var(--fg)] mb-2">Brand Color</label>
                 <div className="flex items-center gap-2">
                   <input
                     id="brand-color"
                     type="color"
                     value={brandColor}
                     onChange={(e) => setBrandColor(e.target.value)}
                     className="w-8 h-8 rounded border border-[var(--border)] cursor-pointer"
                   />
                   <input
                     type="text"
                     value={brandColor}
                     onChange={(e) => setBrandColor(e.target.value)}
                     className="px-2 py-1 text-sm border border-[var(--border)] rounded bg-[var(--surface)] text-[var(--fg)]"
                     style={{ flex: 1 }}
                   />
                 </div>
               </div>
            </div>
          </Card>

           {/* Auto-Generation Status & Manual Controls */}
           <Card className="p-4">
             <h3 className="font-medium text-[var(--fg)] mb-3">
               Brand-Specific Media Packs
             </h3>
             {isGenerating ? (
               <div className="space-y-3">
                 <div className="flex items-center gap-2 text-sm text-[var(--muted-fg)]">
                   <div className="w-4 h-4 border-2 border-[var(--brand-600)] border-t-transparent rounded-full animate-spin"/>
                   Generating for {approvedBrands.length} brand{approvedBrands.length === 1 ? '' : 's'}...
                 </div>
                 <p className="text-xs text-[var(--muted-fg)]">
                   This takes 30-60 seconds per pack. Please wait...
                 </p>
               </div>
             ) : generatedPDFs.length > 0 ? (
               <div className="space-y-3">
                 <div className="text-sm text-green-600 font-medium">
                   ‚úÖ {generatedPDFs.length} pack{generatedPDFs.length === 1 ? '' : 's'} generated
                 </div>
                 <p className="text-xs text-[var(--muted-fg)]">
                   Scroll down to preview, download, or use in outreach
                 </p>
                 <button
                   onClick={() => {
                     setGeneratedPDFs([]);
                     setAutoGeneratedOnce(false);
                     window.location.reload();
                   }}
                   className="w-full px-3 py-2 text-sm border border-[var(--border)] rounded hover:bg-[var(--border)] transition"
                 >
                   üîÑ Regenerate All Packs
                 </button>
               </div>
             ) : (
               <div className="space-y-3">
                 <div className="text-sm text-[var(--muted-fg)]">
                   Ready to generate {approvedBrands.length} pack{approvedBrands.length === 1 ? '' : 's'}
                 </div>
                 <button
                   onClick={() => {
                     setAutoGeneratedOnce(false);
                     window.location.reload();
                   }}
                   className="w-full px-3 py-2 text-sm bg-[var(--brand-600)] text-white rounded hover:bg-[var(--brand-700)] transition font-medium"
                 >
                   üì¶ Generate Packs Now
                 </button>
               </div>
             )}
           </Card>
        </div>

         {/* Right - Live Preview */}
         <div className="lg:col-span-3">
           <Card className="p-0 overflow-hidden">
             <div ref={previewRef} className="h-[800px] overflow-auto">
               {renderTemplate()}
             </div>
           </Card>
         </div>
       </div>

       {/* Brand-Specific Media Packs List (Auto-Generated) */}
       {generatedPDFs.length > 0 && (
         <div className="mt-8" data-generated-packs>
           <Card className="p-6 bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-blue-200">
             <div className="flex items-center justify-between mb-4">
               <div>
                 <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-2">
                   <span>üì¶</span>
                   Generated Media Packs ({generatedPDFs.length})
                 </h2>
                 <p className="text-sm text-gray-600 mt-1">
                   Each pack is customized for the specific brand. Preview, download, or use directly in outreach.
                 </p>
               </div>
               <button
                 onClick={() => {
                   if (confirm('Regenerate all media packs? This will create new PDFs for all brands.')) {
                     setGeneratedPDFs([]);
                     setAutoGeneratedOnce(false);
                     window.location.reload();
                   }
                 }}
                 className="px-4 py-2 text-sm border border-gray-300 bg-white rounded-lg hover:bg-gray-50 transition font-medium"
               >
                 üîÑ Regenerate All
              </button>
            </div>
            
            {/* Quick Selection Actions */}
            {generatedPDFs.filter(p => p.fileUrl && !p.error).length > 0 && (
              <div className="flex items-center justify-between mb-4 pb-4 border-b border-blue-200">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-gray-700">
                    {selectedPackIds.length} of {generatedPDFs.filter(p => p.fileUrl && !p.error).length} selected for outreach
                  </span>
                </div>
                
                <div className="flex gap-2">
                  <button
                    onClick={() => {
                      const allPackIds = generatedPDFs
                        .filter(p => p.fileUrl && !p.error)
                        .map(p => p.brandId || p.brandName);
                      setSelectedPackIds(allPackIds);
                    }}
                    className="text-sm text-blue-600 hover:text-blue-700 font-medium px-3 py-1 rounded hover:bg-blue-100 transition"
                  >
                    ‚úì Select All
                  </button>
                  <span className="text-gray-300">|</span>
                  <button
                    onClick={() => setSelectedPackIds([])}
                    className="text-sm text-gray-600 hover:text-gray-700 font-medium px-3 py-1 rounded hover:bg-gray-100 transition"
                  >
                    Deselect All
                  </button>
                </div>
              </div>
            )}
            
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {generatedPDFs.map((pdf, index) => {
                const brand = approvedBrands.find(b => b.id === pdf.brandId)
                const timeAgo = 'just now' // Could calculate actual time
                const packId = pdf.brandId || pdf.brandName;
                const isSelected = selectedPackIds.includes(packId);
                const canSelect = pdf.fileUrl && !pdf.error;
                
                return (
                  <div
                    key={index}
                    className={`border-2 rounded-lg p-5 transition-all ${
                      isSelected
                        ? 'border-blue-500 bg-blue-50 shadow-xl'
                        : 'border-gray-200 bg-white hover:shadow-md hover:border-blue-300'
                    } ${!canSelect ? 'opacity-50' : ''}`}
                  >
                    {/* Selection Checkbox - Top */}
                    {canSelect && (
                      <div className="flex items-center justify-between mb-4 pb-3 border-b border-gray-200">
                        <label className="flex items-center gap-2 cursor-pointer">
                          <input
                            type="checkbox"
                            checked={isSelected}
                            onChange={() => togglePackSelection(packId)}
                            className="w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                          />
                          <span className="font-medium text-gray-900 text-sm">
                            Use in outreach
                          </span>
                        </label>
                        {isSelected && (
                          <span className="px-2 py-1 bg-blue-600 text-white text-xs font-bold rounded-full">
                            SELECTED
                          </span>
                        )}
                      </div>
                    )}
                    
                    {/* Pack Header */}
                    <div className="flex items-start gap-3 mb-4">
                      <div className={`w-14 h-14 rounded-xl flex items-center justify-center flex-shrink-0 text-2xl ${
                        isSelected ? 'bg-gradient-to-br from-blue-200 to-indigo-200' : 'bg-gradient-to-br from-blue-100 to-indigo-100'
                      }`}>
                        {isSelected ? '‚úì' : 'üìÑ'}
                      </div>
                      <div className="flex-1 min-w-0">
                        <h3 className="font-bold text-gray-900 text-lg truncate">
                          {pdf.brandName}
                        </h3>
                        <p className="text-sm text-gray-600 mt-0.5">
                          Media Pack
                        </p>
                      </div>
                    </div>
                     
                     {/* Pack Info */}
                     <div className="space-y-2 mb-4">
                       <div className="flex items-center gap-2 text-sm text-gray-600">
                         <span>üé®</span>
                         <span className="capitalize">{pdf.variant || variant} variant</span>
                       </div>
                       <div className="flex items-center gap-2 text-sm text-gray-600">
                         <span>‚è±Ô∏è</span>
                         <span>Generated {timeAgo}</span>
                       </div>
                       {pdf.fileName && (
                         <div className="flex items-center gap-2 text-sm text-gray-600">
                           <span>üìé</span>
                           <span className="truncate text-xs">{pdf.fileName}</span>
                         </div>
                       )}
                       {isSelected ? (
                         <div className="flex items-center gap-2 text-sm text-blue-600 font-bold">
                           <span>‚úì</span>
                           <span>Will auto-attach to {pdf.brandName} contacts</span>
                         </div>
                       ) : pdf.fileUrl ? (
                         <div className="flex items-center gap-2 text-sm text-green-600 font-medium">
                           <span>‚úÖ</span>
                           <span>Ready to send</span>
                         </div>
                       ) : null}
                     </div>
                     
                     {/* Error Display */}
                     {pdf.error && (
                       <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                         <p className="text-sm text-red-800">
                           ‚ùå {pdf.error}
                         </p>
                       </div>
                     )}
                     
                    {/* Action Buttons - Preview & Download Only */}
                    {!pdf.error && pdf.fileUrl && (
                      <div className="grid grid-cols-2 gap-2">
                        <button
                          onClick={() => openPDF(pdf.fileUrl)}
                          className="px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition text-sm font-medium flex items-center justify-center gap-1"
                        >
                          <span>üëÅÔ∏è</span>
                          <span>Preview</span>
                        </button>
                        <button
                          onClick={() => downloadPDF(pdf.fileUrl, pdf.brandName)}
                          className="px-3 py-2 border-2 border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition text-sm font-medium flex items-center justify-center gap-1"
                        >
                          <span>‚¨áÔ∏è</span>
                          <span>Download</span>
                        </button>
                      </div>
                    )}
                     
                     {/* Retry Button (if error) */}
                     {pdf.error && (
                       <button
                         onClick={() => {
                           setGeneratedPDFs(prev => prev.filter(p => p.brandId !== pdf.brandId));
                           // Could trigger regeneration for this specific pack
                         }}
                         className="w-full px-3 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition text-sm font-medium flex items-center justify-center gap-1"
                       >
                         <span>üîÑ</span>
                         <span>Retry Generation</span>
                       </button>
                     )}
                   </div>
                 )
               })}
            </div>
            
            {/* Continue to Outreach - Single Button with Selection Info */}
            <div className="mt-6 pt-6 border-t-2 border-blue-200">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-1">
                    Ready to Start Outreach?
                  </h3>
                  <p className="text-sm text-gray-600">
                    {selectedPackIds.length > 0 ? (
                      <>
                        <span className="font-medium text-blue-600">
                          {selectedPackIds.length} pack{selectedPackIds.length !== 1 ? 's' : ''} selected
                        </span>
                        {' ‚Ä¢ '}
                        Will auto-attach to matching brand contacts
                      </>
                    ) : (
                      'Select packs above to use in outreach'
                    )}
                  </p>
                  
                  {/* Show which brands are selected */}
                  {selectedPackIds.length > 0 && (
                    <div className="flex flex-wrap gap-2 mt-3">
                      {selectedPackIds.map(packId => {
                        const pack = generatedPDFs.find(p =>
                          (p.brandId || p.brandName) === packId
                        );
                        return pack ? (
                          <div
                            key={packId}
                            className="px-3 py-1 bg-blue-600 text-white text-xs font-semibold rounded-full flex items-center gap-1"
                          >
                            <span>‚úì</span>
                            <span>{pack.brandName}</span>
                          </div>
                        ) : null;
                      })}
                    </div>
                  )}
                </div>
                
                <button
                  onClick={() => {
                    if (selectedPackIds.length === 0) {
                      toast.error('Please select at least one media pack');
                      return;
                    }
                    
                    console.log(`üöÄ Continuing to outreach with ${selectedPackIds.length} pack(s)`);
                    toast.success(`${selectedPackIds.length} pack${selectedPackIds.length !== 1 ? 's' : ''} ready for outreach!`);
                    router.push(`/${locale}/tools/outreach`);
                  }}
                  disabled={selectedPackIds.length === 0}
                  className={`px-8 py-3 rounded-lg font-semibold text-lg shadow-lg transition ${
                    selectedPackIds.length > 0
                      ? 'bg-gradient-to-r from-blue-600 to-indigo-600 text-white hover:from-blue-700 hover:to-indigo-700'
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  Continue to Outreach ‚Üí
                </button>
              </div>
            </div>
          </Card>
        </div>
       )}
       
       {/* Loading State - Show while generating */}
       {isGenerating && generatedPDFs.length === 0 && (
         <div className="mt-8">
           <Card className="p-8 border-2 border-dashed border-blue-300 bg-blue-50">
             <div className="flex flex-col items-center justify-center space-y-4">
               <div className="w-16 h-16 border-4 border-blue-600 border-t-transparent rounded-full animate-spin" />
               <div className="text-center">
                 <h3 className="text-lg font-semibold text-gray-900 mb-2">
                   Generating Media Packs...
                 </h3>
                 <p className="text-gray-600">
                   Creating {approvedBrands.length} brand-specific pack{approvedBrands.length !== 1 ? 's' : ''}
                 </p>
                 <p className="text-sm text-gray-500 mt-2">
                   This usually takes 30-60 seconds per pack. Please wait...
                 </p>
               </div>
             </div>
           </Card>
         </div>
       )}
      </div>

      {/* NEW: Continue button - show after PDFs generated or skip */}
      {enabled && (
        <div className="mt-8 flex justify-end">
          <button
            onClick={async () => {
              try {
                console.log('üéØ Advancing to outreach step...');
                
                // First, advance the workflow to OUTREACH step
                await fetch('/api/brand-run/upsert', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ step: 'OUTREACH' })
                });
                
                console.log('‚úÖ Advanced to OUTREACH, navigating to:', `/${locale}/tools/outreach`);
                
                // Then navigate to the outreach page with correct locale
                router.push(`/${locale}/tools/outreach`);
              } catch (error) {
                console.error('‚ùå Error advancing to outreach:', error);
                toast.error('Failed to continue to outreach');
              }
            }}
            className="inline-flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-[var(--ds-success)] to-[var(--ds-success-hover)] text-white font-semibold rounded-lg shadow-lg hover:scale-105 transition-all duration-200"
          >
            Continue to Outreach ‚Üí
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7l5 5m0 0l-5 5m5-5H6" />
            </svg>
          </button>
        </div>
      )}
    </PageShell>
  )
}